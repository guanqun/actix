var searchIndex = {};
searchIndex["actix"] = {"doc":"Actix is a rust actor framework.","items":[[3,"SpawnHandle","actix","Spawned future handle. Could be used for cancelling spawned future.",null,null],[3,"Arbiter","","Event loop controller",null,null],[3,"Address","","Address of the actor",null,null],[3,"SyncAddress","","`Send` address of the actor. Actor can run in differend thread",null,null],[3,"Context","","Actor execution context",null,null],[3,"FramedContext","","Actor execution context for Framed object",null,null],[3,"Request","","`Request` is a `Future` which represents asyncronous message sending process.",null,null],[3,"Response","","`Response` represents asyncronous message handling process.",null,null],[3,"Registry","","Actors registry",null,null],[3,"SystemRegistry","","System wide actors registry",null,null],[3,"System","","System is an actor which manages process.",null,null],[3,"SystemRunner","","Helper object that runs System's event loop",null,null],[3,"Supervisor","","Actor supervisor",null,null],[4,"ActorState","","Actor execution state",null,null],[13,"Started","","Actor is started.",0,null],[13,"Running","","Actor is running.",0,null],[13,"Stopping","","Actor is stopping.",0,null],[13,"Stopped","","Actor is stopped.",0,null],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"actorstate"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"spawnhandle"}}],[11,"hash","","",1,null],[11,"next","","Get next handle",1,{"inputs":[{"name":"self"}],"output":{"name":"spawnhandle"}}],[11,"default","","",1,{"inputs":[],"output":{"name":"spawnhandle"}}],[11,"started","","",2,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[11,"new","","Spawn new thread and run event loop in spawned thread. Returns address of newly created arbiter.",2,{"inputs":[{"name":"t"}],"output":{"name":"syncaddress"}}],[11,"name","","Returns current arbiter's address",2,{"inputs":[],"output":{"name":"string"}}],[11,"arbiter","","Returns current arbiter's address",2,{"inputs":[],"output":{"name":"address"}}],[11,"system","","This function returns system address,",2,{"inputs":[],"output":{"name":"syncaddress"}}],[11,"system_arbiter","","This function returns system address,",2,{"inputs":[],"output":{"name":"syncaddress"}}],[11,"system_name","","This function returns system name,",2,{"inputs":[],"output":{"name":"string"}}],[11,"system_registry","","This function returns system registry,",2,{"inputs":[],"output":{"name":"systemregistry"}}],[11,"handle","","This function returns current event loop's handle,",2,{"inputs":[],"output":{"name":"handle"}}],[11,"registry","","This function returns arbiter's registry,",2,{"inputs":[],"output":{"name":"registry"}}],[11,"start","","Start new arbiter and then start actor in created arbiter. Returns `SyncAddress` of created actor.",2,{"inputs":[{"name":"f"}],"output":{"name":"syncaddress"}}],[11,"handle","","",2,{"inputs":[{"name":"self"},{"name":"stoparbiter"},{"name":"context"}],"output":{"name":"response"}}],[11,"handle","","",2,{"inputs":[{"name":"self"},{"name":"startactor"},{"name":"context"}],"output":{"name":"response"}}],[11,"handle","","",2,{"inputs":[{"name":"self"},{"name":"execute"},{"name":"context"}],"output":{"name":"response"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"connected","","Indicates if address is still connected to the actor.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"send","","Send message `M` to actor `A`. Communication channel to the actor is unbuonded.",3,{"inputs":[{"name":"self"},{"name":"m"}],"output":null}],[11,"call","","Send message to actor `A` and asyncronously wait for response. Communication channel to the actor is unbuonded.",3,{"inputs":[{"name":"self"},{"name":"b"},{"name":"m"}],"output":{"name":"request"}}],[11,"call_fut","","Send message to the actor `A` and asyncronously wait for response.",3,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"name":"receiver"}}],[11,"upgrade","","Upgrade address to SyncAddress.",3,{"inputs":[{"name":"self"}],"output":{"name":"receiver"}}],[11,"subscriber","","Get `Subscriber` for specific message type",3,{"inputs":[{"name":"self"}],"output":{"name":"box"}}],[11,"send","","",3,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"name":"result"}}],[11,"boxed","","",3,{"inputs":[{"name":"self"}],"output":{"name":"box"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"connected","","Indicates if address is still connected to the actor.",4,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"send","","Send message `M` to actor `A`. Message cold be sent to actor running in different thread.",4,{"inputs":[{"name":"self"},{"name":"m"}],"output":null}],[11,"call","","Send message to actor `A` and asyncronously wait for response.",4,{"inputs":[{"name":"self"},{"name":"b"},{"name":"m"}],"output":{"name":"request"}}],[11,"call_fut","","Send message to actor `A` and asyncronously wait for response.",4,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"name":"syncreceiver"}}],[11,"subscriber","","Get `Subscriber` for specific message type",4,{"inputs":[{"name":"self"}],"output":{"name":"box"}}],[11,"send","","",4,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"name":"result"}}],[11,"boxed","","",4,{"inputs":[{"name":"self"}],"output":{"name":"box"}}],[11,"stop","","Stop actor execution",5,{"inputs":[{"name":"self"}],"output":null}],[11,"terminate","","Terminate actor execution",5,{"inputs":[{"name":"self"}],"output":null}],[11,"state","","Actor execution state",5,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[11,"spawn","","",5,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[11,"wait","","",5,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"cancel_future","","",5,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"cancel_future_on_stop","","",5,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":null}],[11,"address_cell","","",5,{"inputs":[{"name":"self"}],"output":{"name":"actoraddresscell"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"pack","","",5,{"inputs":[{"name":"m"},{"name":"option"}],"output":{"name":"envelope"}}],[11,"pack","","",6,{"inputs":[{"name":"m"},{"name":"option"}],"output":{"name":"envelope"}}],[11,"stop","","Stop actor execution",6,{"inputs":[{"name":"self"}],"output":null}],[11,"terminate","","Terminate actor execution",6,{"inputs":[{"name":"self"}],"output":null}],[11,"state","","Actor execution state",6,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[11,"spawn","","",6,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[11,"wait","","",6,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"cancel_future","","",6,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"cancel_future_on_stop","","",6,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":null}],[11,"address_cell","","",6,{"inputs":[{"name":"self"}],"output":{"name":"actoraddresscell"}}],[11,"send","","Send item to sink. If sink is closed item returned as an error.",6,null],[11,"close","","Gracefully close Framed object. FramedContext will try to send all buffered items and then close. FramedContext::stop() could be used to force stop sending process.",6,{"inputs":[{"name":"self"}],"output":null}],[11,"drain","","Initiate sink drain",6,{"inputs":[{"name":"self"}],"output":{"name":"unsyncreceiver"}}],[11,"take_framed","","Get inner framed object",6,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",7,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"poll","","",7,null],[11,"from","","",8,{"inputs":[{"name":"t"}],"output":{"name":"response"}}],[11,"from","","",8,{"inputs":[{"name":"result"}],"output":{"name":"response"}}],[11,"reply","","Create response",8,null],[11,"async_reply","","Create async response",8,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"empty","","Create unit response",8,{"inputs":[],"output":{"name":"self"}}],[11,"error","","Create error response",8,null],[11,"get","","Query registry for specific actor. Returns address of the actor. If actor is not registered, starts new actor and return address of newly created actor.",9,{"inputs":[{"name":"self"}],"output":{"name":"address"}}],[11,"get","","Return addres of the service. If service actor is not running it get started in system arbiter.",10,{"inputs":[{"name":"self"}],"output":{"name":"syncaddress"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"new","","Create new system",11,{"inputs":[{"name":"t"}],"output":{"name":"systemrunner"}}],[11,"handle","","Returns handle to the current event loop.",12,{"inputs":[{"name":"self"}],"output":{"name":"handle"}}],[11,"run","","This function will start event loop and will finish once the `SystemExit` message get received.",12,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"handle","","",11,{"inputs":[{"name":"self"},{"name":"systemexit"},{"name":"context"}],"output":{"name":"response"}}],[11,"start","","Start new supervised actor. Depends on `lazy` argument actor could be started immidietly or on first incoming message.",13,null],[11,"start_in","","Start new supervised actor in arbiter's thread. Depends on `lazy` argument actor could be started immidietly or on first incoming message.",13,{"inputs":[{"name":"syncaddress"},{"name":"bool"},{"name":"f"}],"output":{"name":"option"}}],[0,"fut","","Custom `Future` implementation with `Actix` support",null,null],[3,"AndThen","actix::fut","Future for the `and_then` combinator, chaining a computation onto the end of another future which completes successfully.",null,null],[3,"Then","","Future for the `then` combinator, chaining computations on the end of another future regardless of its outcome.",null,null],[3,"Map","","Future for the `map` combinator, changing the type of a future.",null,null],[3,"MapErr","","Future for the `map_err` combinator, changing the error type of a future.",null,null],[3,"DropErr","","",null,null],[3,"FutureResult","","A future representing a value that is immediately ready.",null,null],[3,"StreamMap","","A stream combinator which will change the type of a stream from one type to another.",null,null],[3,"StreamMapErr","","A stream combinator which will change the error type of a stream from one type to another.",null,null],[3,"StreamThen","","A stream combinator which chains a computation onto each item produced by a stream.",null,null],[3,"StreamAndThen","","A stream combinator which chains a computation onto values produced by a stream.",null,null],[3,"StreamFinish","","A combinator used to convert stream into a future, future resolves when stream completes.",null,null],[3,"StreamFold","","A future used to collect all the results of a stream into one generic type.",null,null],[3,"Finish","","A combinator used to convert stream into a future, future resolves when stream completes.",null,null],[3,"FutureWrap","","",null,null],[3,"StreamWrap","","",null,null],[4,"Either","","Combines two different futures yielding the same item and error types into a single type.",null,null],[13,"A","","First branch of the type",14,null],[13,"B","","Second branch of the type",14,null],[5,"result","","Creates a new \"leaf future\" which will resolve with the given result.",null,{"inputs":[{"name":"result"}],"output":{"name":"futureresult"}}],[5,"ok","","Creates a \"leaf future\" from an immediate value of a finished and successful computation.",null,{"inputs":[{"name":"t"}],"output":{"name":"futureresult"}}],[5,"err","","Creates a \"leaf future\" from an immediate value of a failed computation.",null,{"inputs":[{"name":"e"}],"output":{"name":"futureresult"}}],[5,"wrap_future","","Converts normal future into `ActorFuture`",null,{"inputs":[{"name":"f"}],"output":{"name":"futurewrap"}}],[5,"wrap_stream","","Converts normal stream into `ActorStream`",null,{"inputs":[{"name":"s"}],"output":{"name":"streamwrap"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",15,null],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"split","","Splits out the homogeneous type from an either of tuples.",14,null],[11,"poll","","",14,null],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",16,null],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",17,null],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",18,null],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",19,null],[11,"poll","","",20,null],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",21,null],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",22,null],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",23,null],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",24,null],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",25,null],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",26,null],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",27,{"inputs":[{"name":"s"}],"output":{"name":"finish"}}],[11,"poll","","",27,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[8,"ActorFuture","","Trait for types which are a placeholder of a value that may become available at some later point in time.",null,null],[16,"Item","","The type of value that this future will resolved with if it is successful.",28,null],[16,"Error","","The type of error that this future will resolve with if it fails in a normal fashion.",28,null],[16,"Actor","","The actor within which this future runs",28,null],[10,"poll","","",28,null],[11,"map","","Map this future's result to a different type, returning a new future of the resulting type.",28,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"map"}}],[11,"map_err","","Map this future's error to a different error, returning a new future.",28,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"maperr"}}],[11,"drop_err","","Drop this future's error, returning a new future.",28,{"inputs":[{"name":"self"}],"output":{"name":"droperr"}}],[11,"then","","Chain on a computation for when a future finished, passing the result of the future to the provided closure `f`.",28,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"then"}}],[11,"and_then","","Execute another future after this one has resolved successfully.",28,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"andthen"}}],[8,"ActorStream","","A stream of values, not all of which may have been produced yet.",null,null],[16,"Item","","The type of item this stream will yield on success.",29,null],[16,"Error","","The type of error this stream may generate.",29,null],[16,"Actor","","The actor within which this stream runs.",29,null],[10,"poll","","",29,null],[11,"map","","Converts a stream of type `T` to a stream of type `U`.",29,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"streammap"}}],[11,"map_err","","Converts a stream of error type `T` to a stream of error type `E`.",29,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"streammaperr"}}],[11,"then","","Chain on a computation for when a value is ready, passing the resulting item to the provided closure `f`.",29,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"streamthen"}}],[11,"and_then","","Chain on a computation for when a value is ready, passing the successful results to the provided closure `f`.",29,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"streamandthen"}}],[11,"fold","","Execute an accumulating computation over a stream, collecting all the values into one final result.",29,{"inputs":[{"name":"self"},{"name":"t"},{"name":"f"}],"output":{"name":"streamfold"}}],[11,"finish","","Converts a stream to a future that resolves when stream completes.",29,{"inputs":[{"name":"self"}],"output":{"name":"streamfinish"}}],[8,"IntoActorFuture","","Class of types which can be converted into an actor future.",null,null],[16,"Future","","The future that this type can be converted into.",30,null],[16,"Item","","The item that the future may resolve with.",30,null],[16,"Error","","The error that the future may resolve with.",30,null],[16,"Actor","","The actor within which this future runs",30,null],[10,"into_future","","Consumes this object and produces a future.",30,null],[8,"WrapFuture","","Helper trait that allows conversion of normal future into `ActorFuture`",null,null],[16,"Future","","The future that this type can be converted into.",31,null],[16,"Item","","The item that the future may resolve with.",31,null],[16,"Error","","The error that the future may resolve with.",31,null],[10,"actfuture","","",31,null],[8,"WrapStream","","Helper trait that allows conversion of normal stream into `ActorStream`",null,null],[16,"Stream","","The stream that this type can be converted into.",32,null],[16,"Item","","The item that the future may resolve with.",32,null],[16,"Error","","The error that the future may resolve with.",32,null],[10,"actstream","","",32,null],[11,"poll","","",33,null],[11,"poll","","",34,null],[0,"prelude","actix","The `actix` prelude",null,null],[3,"SpawnHandle","actix::prelude","Spawned future handle. Could be used for cancelling spawned future.",null,null],[3,"Arbiter","","Event loop controller",null,null],[3,"Address","","Address of the actor",null,null],[3,"SyncAddress","","`Send` address of the actor. Actor can run in differend thread",null,null],[3,"Context","","Actor execution context",null,null],[3,"FramedContext","","Actor execution context for Framed object",null,null],[3,"Request","","`Request` is a `Future` which represents asyncronous message sending process.",null,null],[3,"Response","","`Response` represents asyncronous message handling process.",null,null],[3,"System","","System is an actor which manages process.",null,null],[3,"Supervisor","","Actor supervisor",null,null],[4,"ActorState","","Actor execution state",null,null],[13,"Started","","Actor is started.",0,null],[13,"Running","","Actor is running.",0,null],[13,"Stopping","","Actor is stopping.",0,null],[13,"Stopped","","Actor is stopped.",0,null],[0,"actix","","",null,null],[8,"Actor","","Actors are objects which encapsulate state and behavior.",null,null],[16,"Context","","Actor execution context type",35,null],[11,"started","","Method is called when actor get polled first time.",35,null],[11,"stopping","","Method is called after an actor is in `Actor::Stopping` state. There could be several reasons for stopping. `Context::stop` get called by the actor itself. All addresses to current actor get dropped and no more evented objects left in the context. Actor could restore from stopping state to running state by creating new address or adding future or stream to current content.",35,null],[11,"stopped","","Method is called after an actor is stopped, it can be used to perform any needed cleanup work or spawning more actors. This is final state, after this call actor get dropped.",35,null],[11,"start","","Start new asynchronous actor, returns address of newly created actor.",35,{"inputs":[{"name":"self"}],"output":{"name":"addr"}}],[11,"start_default","","Start new asynchronous actor, returns address of newly created actor.",35,{"inputs":[],"output":{"name":"addr"}}],[11,"create","","Use `create` method, if you need `Context` object during actor initialization.",35,{"inputs":[{"name":"f"}],"output":{"name":"addr"}}],[11,"reply","","Create static response.",35,null],[11,"async_reply","","Create async response process.",35,{"inputs":[{"name":"t"}],"output":{"name":"response"}}],[11,"empty","","Create unit response, for case when `ResponseType::Item = ()`",35,{"inputs":[],"output":{"name":"response"}}],[11,"reply_error","","Create error response",35,null],[8,"FramedActor","","Actor trait that allows to handle `tokio_io::codec::Framed` objects.",null,null],[16,"Io","","Io type",36,null],[16,"Codec","","Codec type",36,null],[11,"error","","Method is called on sink error. By default it does nothing.",36,null],[11,"framed","","Start new actor, returns address of this actor.",36,null],[11,"from_framed","","Start new actor, returns address of this actor.",36,{"inputs":[{"name":"self"},{"name":"framed"}],"output":{"name":"addr"}}],[11,"create_framed","","This function starts new actor, returns address of this actor. Actor is created by factory function.",36,null],[11,"create_from_framed","","This function starts new actor, returns address of this actor. Actor is created by factory function.",36,{"inputs":[{"name":"framed"},{"name":"f"}],"output":{"name":"addr"}}],[8,"Supervised","","Actors with ability to restart after failure",null,null],[11,"restarting","","Method called when supervisor restarting failed actor",37,null],[8,"Handler","","Message handler",null,null],[10,"handle","","Method is called for every message received by this Actor",38,null],[11,"error","","Method is called on error. By default it does nothing.",38,null],[8,"ResponseType","","Message response type",null,null],[16,"Item","","The type of value that this message will resolved with if it is successful.",39,null],[16,"Error","","The type of error that this message will resolve with if it fails in a normal fashion.",39,null],[8,"StreamHandler","","Stream handler",null,null],[11,"started","","Method is called when stream get polled first time.",40,null],[11,"finished","","Method is called when stream finishes, even if stream finishes with error.",40,null],[8,"ActorContext","","Actor execution context",null,null],[10,"stop","","Gracefuly stop actor execution",41,{"inputs":[{"name":"self"}],"output":null}],[10,"terminate","","Terminate actor execution",41,{"inputs":[{"name":"self"}],"output":null}],[10,"state","","Actor execution state",41,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[11,"alive","","Check if execution context is alive",41,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"AsyncContext","","Asynchronous execution context",null,null],[11,"address","","Get actor address",42,{"inputs":[{"name":"self"}],"output":{"name":"address"}}],[10,"spawn","","Spawn async future into context. Returns handle of the item, could be used for cancelling execution.",42,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[10,"wait","","Spawn future into the context. Stop processing any of incoming events until this future resolves.",42,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[10,"cancel_future","","Cancel future. idx is a value returned by `spawn` method.",42,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"add_future","","This method allow to handle Future in similar way as normal actor messages.",42,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"add_stream","","This method is similar to `add_future` but works with streams.",42,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"notify","","Send message `msg` to self after specified period of time. Returns spawn handle which could be used for cancelation. Notification get cancelled if context's stop method get called.",42,{"inputs":[{"name":"self"},{"name":"m"},{"name":"duration"}],"output":{"name":"spawnhandle"}}],[11,"run_later","","Execute closure after specified period of time within same Actor and Context Execution get cancelled if context's stop method get called.",42,{"inputs":[{"name":"self"},{"name":"duration"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[8,"Subscriber","","",null,null],[10,"send","","Send buffered message",43,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"name":"result"}}],[10,"boxed","","Create boxed clone of the current subscriber",43,{"inputs":[{"name":"self"}],"output":{"name":"box"}}],[8,"ContextFutureSpawner","","Helper trait which can spawn future into actor's context",null,null],[10,"spawn","","spawn future into `Context<A>`",44,null],[10,"wait","","Spawn future into the context. Stop processing any of incoming events until this future resolves.",44,null],[8,"ToEnvelope","","Converter trait, packs message to suitable envelope",null,null],[10,"pack","","Pack message into suitable envelope",45,{"inputs":[{"name":"m"},{"name":"option"}],"output":{"name":"envelope"}}],[8,"ArbiterService","","Trait defines arbiter's service.",null,null],[11,"service_started","","Method is called during service initialization.",46,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[8,"SystemService","","Trait defines system's service.",null,null],[11,"service_started","","Method is called during service initialization.",47,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[0,"actors","actix","Helper actors",null,null],[0,"signal","actix::actors","An actor implementation of Unix signal handling",null,null],[3,"Signal","actix::actors::signal","Process signal message",null,null],[12,"0","","",48,null],[3,"ProcessSignals","","An actor implementation of Unix signal handling",null,null],[3,"Subscribe","","Subscribe to process signals.",null,null],[12,"0","","",49,null],[3,"DefaultSignalsHandler","","Default signals handler. This actor sends `SystemExit` message to `System` actor for each of `SIGINT`, `SIGTERM`, `SIGQUIT` signals.",null,null],[4,"SignalType","","Different types of process signals",null,null],[13,"Hup","","SIGHUP",50,null],[13,"Int","","SIGINT",50,null],[13,"Term","","SIGTERM",50,null],[13,"Quit","","SIGQUIT",50,null],[13,"Child","","SIGCHILD",50,null],[11,"eq","","",50,{"inputs":[{"name":"self"},{"name":"signaltype"}],"output":{"name":"bool"}}],[11,"clone","","",50,{"inputs":[{"name":"self"}],"output":{"name":"signaltype"}}],[11,"fmt","","",50,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",51,{"inputs":[],"output":{"name":"self"}}],[11,"service_started","","",51,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[11,"handle","","",51,{"inputs":[{"name":"self"},{"name":"subscribe"},{"name":"context"}],"output":{"name":"response"}}],[11,"default","","",52,{"inputs":[],"output":{"name":"self"}}],[11,"started","","",52,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[11,"handle","","",52,{"inputs":[{"name":"self"},{"name":"signal"},{"name":"context"}],"output":{"name":"response"}}],[0,"msgs","actix","Actix system messages",null,null],[3,"SystemExit","actix::msgs","Stop system execution",null,null],[12,"0","","",53,null],[3,"StopArbiter","","Stop arbiter execution",null,null],[12,"0","","",54,null],[3,"StartActor","","Start actor in arbiter's thread",null,null],[3,"Execute","","Execute function in arbiter's thread",null,null],[11,"new","","",55,{"inputs":[{"name":"f"}],"output":{"name":"self"}}],[11,"new","","",56,{"inputs":[{"name":"f"}],"output":{"name":"self"}}],[11,"exec","","Execute enclosed function",56,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[0,"sync","actix","Sync actors support",null,null],[3,"SyncArbiter","actix::sync","Sync arbiter",null,null],[3,"SyncContext","","Sync actor execution context",null,null],[11,"start","","Start new sync arbiter with specified number of worker threads. Returns address of started actor.",57,{"inputs":[{"name":"usize"},{"name":"f"}],"output":{"name":"syncaddress"}}],[11,"pack","","",58,{"inputs":[{"name":"m"},{"name":"option"}],"output":{"name":"envelope"}}],[11,"stop","","Stop actor execution",58,{"inputs":[{"name":"self"}],"output":null}],[11,"terminate","","Terminate actor execution",58,{"inputs":[{"name":"self"}],"output":null}],[11,"state","","Actor execution state",58,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[0,"dev","actix","The `actix` prelude for library developers",null,null],[3,"ActorAddressCell","actix::dev","",null,null],[3,"ActorItemsCell","","",null,null],[3,"ActorWaitCell","","",null,null],[3,"Envelope","","",null,null],[3,"RemoteEnvelope","","",null,null],[8,"ActorAddress","","Trait give access to actor's address",null,null],[10,"get","","Returns actor's address for specific context",59,null],[8,"AsyncContextApi","","",null,null],[10,"address_cell","","",60,{"inputs":[{"name":"self"}],"output":{"name":"actoraddresscell"}}],[8,"ToEnvelope","","Converter trait, packs message to suitable envelope",null,null],[10,"pack","","Pack message into suitable envelope",45,{"inputs":[{"name":"m"},{"name":"option"}],"output":{"name":"envelope"}}],[0,"constants","actix","",null,null],[17,"MAX_SYNC_POLLS","actix::constants","Maximum number of consecutive polls in a loop",null,null],[8,"Actor","actix","Actors are objects which encapsulate state and behavior.",null,null],[16,"Context","","Actor execution context type",35,null],[11,"started","actix::prelude","Method is called when actor get polled first time.",35,null],[11,"stopping","","Method is called after an actor is in `Actor::Stopping` state. There could be several reasons for stopping. `Context::stop` get called by the actor itself. All addresses to current actor get dropped and no more evented objects left in the context. Actor could restore from stopping state to running state by creating new address or adding future or stream to current content.",35,null],[11,"stopped","","Method is called after an actor is stopped, it can be used to perform any needed cleanup work or spawning more actors. This is final state, after this call actor get dropped.",35,null],[11,"start","","Start new asynchronous actor, returns address of newly created actor.",35,{"inputs":[{"name":"self"}],"output":{"name":"addr"}}],[11,"start_default","","Start new asynchronous actor, returns address of newly created actor.",35,{"inputs":[],"output":{"name":"addr"}}],[11,"create","","Use `create` method, if you need `Context` object during actor initialization.",35,{"inputs":[{"name":"f"}],"output":{"name":"addr"}}],[11,"reply","","Create static response.",35,null],[11,"async_reply","","Create async response process.",35,{"inputs":[{"name":"t"}],"output":{"name":"response"}}],[11,"empty","","Create unit response, for case when `ResponseType::Item = ()`",35,{"inputs":[],"output":{"name":"response"}}],[11,"reply_error","","Create error response",35,null],[8,"FramedActor","actix","Actor trait that allows to handle `tokio_io::codec::Framed` objects.",null,null],[16,"Io","","Io type",36,null],[16,"Codec","","Codec type",36,null],[11,"error","actix::prelude","Method is called on sink error. By default it does nothing.",36,null],[11,"framed","","Start new actor, returns address of this actor.",36,null],[11,"from_framed","","Start new actor, returns address of this actor.",36,{"inputs":[{"name":"self"},{"name":"framed"}],"output":{"name":"addr"}}],[11,"create_framed","","This function starts new actor, returns address of this actor. Actor is created by factory function.",36,null],[11,"create_from_framed","","This function starts new actor, returns address of this actor. Actor is created by factory function.",36,{"inputs":[{"name":"framed"},{"name":"f"}],"output":{"name":"addr"}}],[8,"Supervised","actix","Actors with ability to restart after failure",null,null],[11,"restarting","actix::prelude","Method called when supervisor restarting failed actor",37,null],[8,"Handler","actix","Message handler",null,null],[10,"handle","","Method is called for every message received by this Actor",38,null],[11,"error","actix::prelude","Method is called on error. By default it does nothing.",38,null],[8,"ResponseType","actix","Message response type",null,null],[16,"Item","","The type of value that this message will resolved with if it is successful.",39,null],[16,"Error","","The type of error that this message will resolve with if it fails in a normal fashion.",39,null],[8,"StreamHandler","","Stream handler",null,null],[11,"started","actix::prelude","Method is called when stream get polled first time.",40,null],[11,"finished","","Method is called when stream finishes, even if stream finishes with error.",40,null],[8,"ActorContext","actix","Actor execution context",null,null],[10,"stop","","Gracefuly stop actor execution",41,{"inputs":[{"name":"self"}],"output":null}],[10,"terminate","","Terminate actor execution",41,{"inputs":[{"name":"self"}],"output":null}],[10,"state","","Actor execution state",41,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[11,"alive","actix::prelude","Check if execution context is alive",41,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"AsyncContext","actix","Asynchronous execution context",null,null],[11,"address","actix::prelude","Get actor address",42,{"inputs":[{"name":"self"}],"output":{"name":"address"}}],[10,"spawn","actix","Spawn async future into context. Returns handle of the item, could be used for cancelling execution.",42,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[10,"wait","","Spawn future into the context. Stop processing any of incoming events until this future resolves.",42,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[10,"cancel_future","","Cancel future. idx is a value returned by `spawn` method.",42,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"add_future","actix::prelude","This method allow to handle Future in similar way as normal actor messages.",42,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"add_stream","","This method is similar to `add_future` but works with streams.",42,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"notify","","Send message `msg` to self after specified period of time. Returns spawn handle which could be used for cancelation. Notification get cancelled if context's stop method get called.",42,{"inputs":[{"name":"self"},{"name":"m"},{"name":"duration"}],"output":{"name":"spawnhandle"}}],[11,"run_later","","Execute closure after specified period of time within same Actor and Context Execution get cancelled if context's stop method get called.",42,{"inputs":[{"name":"self"},{"name":"duration"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[8,"Subscriber","actix","",null,null],[10,"send","","Send buffered message",43,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"name":"result"}}],[10,"boxed","","Create boxed clone of the current subscriber",43,{"inputs":[{"name":"self"}],"output":{"name":"box"}}],[8,"ActorAddress","","Trait give access to actor's address",null,null],[10,"get","","Returns actor's address for specific context",59,null],[8,"ContextFutureSpawner","","Helper trait which can spawn future into actor's context",null,null],[10,"spawn","","spawn future into `Context<A>`",44,null],[10,"wait","","Spawn future into the context. Stop processing any of incoming events until this future resolves.",44,null],[8,"ToEnvelope","","Converter trait, packs message to suitable envelope",null,null],[10,"pack","","Pack message into suitable envelope",45,{"inputs":[{"name":"m"},{"name":"option"}],"output":{"name":"envelope"}}],[8,"ArbiterService","","Trait defines arbiter's service.",null,null],[11,"service_started","actix::prelude","Method is called during service initialization.",46,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[8,"SystemService","actix","Trait defines system's service.",null,null],[11,"service_started","actix::prelude","Method is called during service initialization.",47,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[11,"started","","Method is called when actor get polled first time.",35,null],[11,"stopping","","Method is called after an actor is in `Actor::Stopping` state. There could be several reasons for stopping. `Context::stop` get called by the actor itself. All addresses to current actor get dropped and no more evented objects left in the context. Actor could restore from stopping state to running state by creating new address or adding future or stream to current content.",35,null],[11,"stopped","","Method is called after an actor is stopped, it can be used to perform any needed cleanup work or spawning more actors. This is final state, after this call actor get dropped.",35,null],[11,"start","","Start new asynchronous actor, returns address of newly created actor.",35,{"inputs":[{"name":"self"}],"output":{"name":"addr"}}],[11,"start_default","","Start new asynchronous actor, returns address of newly created actor.",35,{"inputs":[],"output":{"name":"addr"}}],[11,"create","","Use `create` method, if you need `Context` object during actor initialization.",35,{"inputs":[{"name":"f"}],"output":{"name":"addr"}}],[11,"reply","","Create static response.",35,null],[11,"async_reply","","Create async response process.",35,{"inputs":[{"name":"t"}],"output":{"name":"response"}}],[11,"empty","","Create unit response, for case when `ResponseType::Item = ()`",35,{"inputs":[],"output":{"name":"response"}}],[11,"reply_error","","Create error response",35,null],[11,"error","","Method is called on sink error. By default it does nothing.",36,null],[11,"framed","","Start new actor, returns address of this actor.",36,null],[11,"from_framed","","Start new actor, returns address of this actor.",36,{"inputs":[{"name":"self"},{"name":"framed"}],"output":{"name":"addr"}}],[11,"create_framed","","This function starts new actor, returns address of this actor. Actor is created by factory function.",36,null],[11,"create_from_framed","","This function starts new actor, returns address of this actor. Actor is created by factory function.",36,{"inputs":[{"name":"framed"},{"name":"f"}],"output":{"name":"addr"}}],[11,"restarting","","Method called when supervisor restarting failed actor",37,null],[11,"error","","Method is called on error. By default it does nothing.",38,null],[11,"started","","Method is called when stream get polled first time.",40,null],[11,"finished","","Method is called when stream finishes, even if stream finishes with error.",40,null],[11,"alive","","Check if execution context is alive",41,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"address","","Get actor address",42,{"inputs":[{"name":"self"}],"output":{"name":"address"}}],[11,"add_future","","This method allow to handle Future in similar way as normal actor messages.",42,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"add_stream","","This method is similar to `add_future` but works with streams.",42,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"notify","","Send message `msg` to self after specified period of time. Returns spawn handle which could be used for cancelation. Notification get cancelled if context's stop method get called.",42,{"inputs":[{"name":"self"},{"name":"m"},{"name":"duration"}],"output":{"name":"spawnhandle"}}],[11,"run_later","","Execute closure after specified period of time within same Actor and Context Execution get cancelled if context's stop method get called.",42,{"inputs":[{"name":"self"},{"name":"duration"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[11,"default","actix::dev","",61,{"inputs":[],"output":{"name":"self"}}],[11,"new","","",61,{"inputs":[{"name":"unboundedreceiver"}],"output":{"name":"self"}}],[11,"close","","",61,{"inputs":[{"name":"self"}],"output":null}],[11,"connected","","",61,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"unsync_sender","","",61,{"inputs":[{"name":"self"}],"output":{"name":"unboundedsender"}}],[11,"unsync_address","","",61,{"inputs":[{"name":"self"}],"output":{"name":"address"}}],[11,"sync_address","","",61,{"inputs":[{"name":"self"}],"output":{"name":"syncaddress"}}],[11,"poll","","",61,null],[11,"default","","",62,{"inputs":[],"output":{"name":"self"}}],[11,"is_empty","","",62,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"close","","",62,{"inputs":[{"name":"self"}],"output":null}],[11,"stop","","",62,{"inputs":[{"name":"self"}],"output":null}],[11,"spawn","","",62,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[11,"cancel_future","","",62,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"cancel_future_on_stop","","",62,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":null}],[11,"poll","","",62,null],[11,"default","","",63,{"inputs":[],"output":{"name":"actorwaitcell"}}],[11,"add","","",63,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"poll","","",63,null],[11,"new","","",64,{"inputs":[{"name":"m"},{"name":"option"}],"output":{"name":"remoteenvelope"}}],[11,"from","","",65,{"inputs":[{"name":"remoteenvelope"}],"output":{"name":"self"}}],[11,"service_started","actix::prelude","Method is called during service initialization.",46,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[11,"service_started","","Method is called during service initialization.",47,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}]],"paths":[[4,"ActorState"],[3,"SpawnHandle"],[3,"Arbiter"],[3,"Address"],[3,"SyncAddress"],[3,"Context"],[3,"FramedContext"],[3,"Request"],[3,"Response"],[3,"Registry"],[3,"SystemRegistry"],[3,"System"],[3,"SystemRunner"],[3,"Supervisor"],[4,"Either"],[3,"AndThen"],[3,"FutureResult"],[3,"Then"],[3,"Map"],[3,"MapErr"],[3,"DropErr"],[3,"StreamMap"],[3,"StreamMapErr"],[3,"StreamThen"],[3,"StreamAndThen"],[3,"StreamFinish"],[3,"StreamFold"],[3,"Finish"],[8,"ActorFuture"],[8,"ActorStream"],[8,"IntoActorFuture"],[8,"WrapFuture"],[8,"WrapStream"],[3,"FutureWrap"],[3,"StreamWrap"],[8,"Actor"],[8,"FramedActor"],[8,"Supervised"],[8,"Handler"],[8,"ResponseType"],[8,"StreamHandler"],[8,"ActorContext"],[8,"AsyncContext"],[8,"Subscriber"],[8,"ContextFutureSpawner"],[8,"ToEnvelope"],[8,"ArbiterService"],[8,"SystemService"],[3,"Signal"],[3,"Subscribe"],[4,"SignalType"],[3,"ProcessSignals"],[3,"DefaultSignalsHandler"],[3,"SystemExit"],[3,"StopArbiter"],[3,"StartActor"],[3,"Execute"],[3,"SyncArbiter"],[3,"SyncContext"],[8,"ActorAddress"],[8,"AsyncContextApi"],[3,"ActorAddressCell"],[3,"ActorItemsCell"],[3,"ActorWaitCell"],[3,"RemoteEnvelope"],[3,"Envelope"]]};
initSearch(searchIndex);
